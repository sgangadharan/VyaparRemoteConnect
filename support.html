<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Support Agent - Remote Assist</title>
    <style>
      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        margin: 20px;
      }

      video {
        max-width: 100%;
        border: 2px solid #333;
        border-radius: 8px;
        background: #000;
      }

      .info {
        margin-bottom: 10px;
      }
    </style>
  </head>
  <body>
    <h1>Support Agent Console</h1>
    <div class="info">
      <div>
        Session Key:
        <input
          id="agentSessionInput"
          type="text"
          placeholder="Enter session key (e.g. customer-123)"
          style="width: 200px;"
        />
        <button id="joinSessionBtn">Join Session</button>
      </div>
      <small>
        Open this page and join the correct session key before the customer clicks
        ‚ÄúStart Remote Assist‚Äù.
      </small>
    </div>

    <video
      id="remoteVideo"
      autoplay
      playsinline
      muted
      style="max-width: 100%; width: 800px; background: #000; border: 2px solid #333; border-radius: 8px;"
    ></video>

    <!-- Socket.IO (no integrity / crossorigin, to avoid blocking) -->
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script>
      // Dynamic session ID, set after Join Session
      let sessionId = null;       // change from const ‚Üí let
      let sessionActive = false;  // new flag

      // If support.html is served from the same host/port as server.js (4000):
      const socket = io(); // auto-connects to current origin
      // or explicitly:
      // const socket = io('http://135.13.10.157:4000');

      const pc = new RTCPeerConnection({
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          {
            urls: 'turn:global.relay.metered.ca:80',
            username: 'openai',
            credential: 'openai'
          },
          {
            urls: 'turn:global.relay.metered.ca:443',
            username: 'openai',
            credential: 'openai'
          },
          {
            urls: 'turn:global.relay.metered.ca:443?transport=tcp',
            username: 'openai',
            credential: 'openai'
          }
        ]
      });

      // FULL WINDOW size (DIP)
      let appWidth = 800;
      let appHeight = 600;

      const video = document.getElementById('remoteVideo');

      socket.on('connect', () => {
        console.log('AGENT: connected to signaling server, id =', socket.id);
        console.log('AGENT: waiting for session key before joining a room');
      });

      // Join a session when the button is clicked
      function joinSession() {
        const key = document.getElementById('agentSessionInput').value.trim();
        if (!key) {
          alert('Please enter a Session Key to join.');
          return;
        }
        sessionId = key;
        sessionActive = true;
        console.log('AGENT: joining session', sessionId);
        socket.emit('register', { role: 'agent', sessionId });
      }

      document.getElementById('joinSessionBtn').addEventListener('click', joinSession);

      // Dimensions from customer (FULL WINDOW bounds)
      socket.on('app-dimensions', ({ width, height }) => {
        appWidth = width;
        appHeight = height;
        console.log('AGENT: window dimensions from customer:', appWidth, appHeight);
      });

      // WebRTC: ICE + offer/answer
      pc.onicecandidate = (event) => {
        if (!event.candidate) return;
        if (!sessionId) {
          console.warn('AGENT: ICE candidate but no sessionId yet, ignoring');
          return;
        }
        console.log('AGENT: sending ICE candidate');
        socket.emit('ice-candidate', { sessionId, candidate: event.candidate });
      };

      socket.on('offer', async ({ offer }) => {
        console.log('AGENT: received OFFER');
        try {
          await pc.setRemoteDescription(new RTCSessionDescription(offer));
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          console.log('AGENT: sending ANSWER');
          if (!sessionId) {
            console.warn('AGENT: got offer but no sessionId yet, ANSWER will not be routed correctly');
            return;
          }
          socket.emit('answer', { sessionId, answer });
        } catch (e) {
          console.error('AGENT: error handling offer:', e);
        }
      });

      socket.on('ice-candidate', async ({ candidate }) => {
        console.log('AGENT: received ICE candidate from customer');
        try {
          await pc.addIceCandidate(new RTCIceCandidate(candidate));
        } catch (e) {
          console.error('AGENT: error adding ICE candidate:', e);
        }
      });

      socket.on('session-ended', ({ sessionId: endedId, reason }) => {
        console.log('AGENT: session ended by client:', endedId, reason);
        sessionActive = false;

        try {
          if (pc) {
            pc.getSenders().forEach(s => pc.removeTrack(s));
            pc.close();
          }
        } catch (e) {
          console.error('AGENT: error closing peer connection after session end', e);
        }

        //pc = null;
        video.srcObject = null;

        alert('Remote session was stopped by the customer. This page will now refresh.');
        window.location.reload();   // üîÅ simple reset UX
      });

      // Attach remote stream
      pc.ontrack = (event) => {
        console.log('AGENT: ontrack fired, attaching stream to video');
        const [stream] = event.streams;
        video.srcObject = stream;
        video.muted = true;
        video.playsInline = true;

        video.onloadedmetadata = () => {
          console.log(
            'AGENT: video metadata loaded, videoWidth=',
            video.videoWidth,
            'videoHeight=',
            video.videoHeight
          );

          const playPromise = video.play();
          if (playPromise && typeof playPromise.then === 'function') {
            playPromise
              .then(() => console.log('AGENT: video playback started'))
              .catch((err) => console.error('AGENT: video play() blocked/failed:', err));
          }
        };
      };

      // ---------------------------------
      // Map video coords -> WINDOW coords
      // ---------------------------------
      function mapToWindowCoords(evt) {
        const rect = video.getBoundingClientRect();

        const relX = (evt.clientX - rect.left) / rect.width;
        const relY = (evt.clientY - rect.top) / rect.height;

        const x = relX * appWidth;
        const y = relY * appHeight;

        return { x, y };
      }

      // Mouse MOVE
      let lastMoveSent = 0;
      const MOVE_THROTTLE_MS = 50;

      video.addEventListener('mousemove', (evt) => {
        if (!sessionActive) return;
        if (!video.videoWidth || !video.videoHeight) return;
        if (!sessionId) return;

        const now = Date.now();
        if (now - lastMoveSent < MOVE_THROTTLE_MS) return;
        lastMoveSent = now;

        const { x, y } = mapToWindowCoords(evt);

        socket.emit('control-event', {
          sessionId,
          event: {
            type: 'mouse',
            subtype: 'mouseMove',
            x,
            y,
            button: 'left'
          }
        });
      });

      // Mouse CLICK
      video.addEventListener('click', (evt) => {
        if (!sessionActive) return;
        if (!sessionId) return;

        if (video.paused) {
          const playPromise = video.play();
          if (playPromise && typeof playPromise.then === 'function') {
            playPromise.catch((err) => {
              console.error('AGENT: video play() failed on click:', err);
            });
          }
        }

        if (!video.videoWidth || !video.videoHeight) {
          console.log('AGENT: click ignored, video not ready yet');
          return;
        }

        const { x, y } = mapToWindowCoords(evt);
        console.log('AGENT: sending click at window coords', { x, y });

        socket.emit('control-event', {
          sessionId,
          event: {
            type: 'mouse',
            subtype: 'mouseDown',
            x,
            y,
            button: 'left'
          }
        });

        socket.emit('control-event', {
          sessionId,
          event: {
            type: 'mouse',
            subtype: 'mouseUp',
            x,
            y,
            button: 'left'
          }
        });
      });

      // Mouse WHEEL (scroll)
      video.addEventListener(
        'wheel',
        (evt) => {
          if (!sessionActive) return;
          if (!sessionId) return;
          if (!video.videoWidth || !video.videoHeight) return;

          // prevent the browser page from scrolling instead
          evt.preventDefault();

          const { x, y } = mapToWindowCoords(evt);

          // Use discrete steps instead of tiny trackpad floats
          const STEP = 120; // standard scroll step

          const deltaY =
            evt.deltaY > 0 ? STEP : evt.deltaY < 0 ? -STEP : 0;
          const deltaX =
            evt.deltaX > 0 ? STEP : evt.deltaX < 0 ? -STEP : 0;

          // If no meaningful movement, skip
          if (!deltaX && !deltaY) return;

          socket.emit('control-event', {
            sessionId,
            event: {
              type: 'mouse',
              subtype: 'mouseWheel',
              x,
              y,
              deltaX,
              deltaY
            }
          });
        },
        { passive: false }
      );

      // Keyboard forwarding
      window.addEventListener('keydown', (evt) => {
        if (!sessionActive) return;
        if (!sessionId) return;

        socket.emit('control-event', {
          sessionId,
          event: {
            type: 'keyboard',
            subtype: 'keyDown',
            key: evt.key,
            code: evt.code,
            altKey: evt.altKey,
            shiftKey: evt.shiftKey,
            ctrlKey: evt.ctrlKey,
            metaKey: evt.metaKey
          }
        });
        evt.preventDefault();
      });

      window.addEventListener('keyup', (evt) => {
        if (!sessionActive) return;
        if (!sessionId) return;

        socket.emit('control-event', {
          sessionId,
          event: {
            type: 'keyboard',
            subtype: 'keyUp',
            key: evt.key,
            code: evt.code,
            altKey: evt.altKey,
            shiftKey: evt.shiftKey,
            ctrlKey: evt.ctrlKey,
            metaKey: evt.metaKey
          }
        });
        evt.preventDefault();
      });
    </script>
  </body>
</html>