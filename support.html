<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Support Agent - Remote Assist</title>
    <style>
      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        margin: 20px;
      }

      video {
        max-width: 100%;
        border: 2px solid #333;
        border-radius: 8px;
        background: #000;
      }

      .info {
        margin-bottom: 10px;
      }
    </style>
  </head>
  <body>
    <h1>Support Agent Console</h1>
    <div class="info">
      Session: <code>demo-session-1</code><br />
      Open this page <strong>before</strong> the customer clicks “Start Remote Assist” in the app.
    </div>

    <video
      id="remoteVideo"
      autoplay
      playsinline
      muted
      style="max-width: 100%; width: 800px; background: #000; border: 2px solid #333; border-radius: 8px;"
    ></video>

    <!-- Socket.IO (no integrity / crossorigin, to avoid blocking) -->
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script>
      const sessionId = 'demo-session-1';

      // If support.html is served from the same host/port as server.js (4000):
      const socket = io();  // auto-connects to current origin
      // or explicitly:
      // const socket = io('http://192.168.137.102:4000'); // adjust IP if needed

      const pc = new RTCPeerConnection({
        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
      });

      // FULL WINDOW size (DIP)
      let appWidth = 800;
      let appHeight = 600;

      const video = document.getElementById('remoteVideo');

      socket.on('connect', () => {
        console.log('AGENT: connected to signaling server, id =', socket.id);
        socket.emit('register', { role: 'agent', sessionId });
      });

      // Now this represents full window bounds (what the video is showing)
      socket.on('app-dimensions', ({ width, height }) => {
        appWidth = width;
        appHeight = height;
        console.log('AGENT: window dimensions from customer:', appWidth, appHeight);
      });

      // WebRTC: ICE + offer/answer
      pc.onicecandidate = (event) => {
        if (event.candidate) {
          console.log('AGENT: sending ICE candidate');
          socket.emit('ice-candidate', { sessionId, candidate: event.candidate });
        }
      };

      socket.on('offer', async ({ offer }) => {
        console.log('AGENT: received OFFER');
        try {
          await pc.setRemoteDescription(new RTCSessionDescription(offer));
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          console.log('AGENT: sending ANSWER');
          socket.emit('answer', { sessionId, answer });
        } catch (e) {
          console.error('AGENT: error handling offer:', e);
        }
      });

      socket.on('ice-candidate', async ({ candidate }) => {
        console.log('AGENT: received ICE candidate from customer');
        try {
          await pc.addIceCandidate(new RTCIceCandidate(candidate));
        } catch (e) {
          console.error('AGENT: error adding ICE candidate:', e);
        }
      });

      // Attach remote stream
      pc.ontrack = (event) => {
        console.log('AGENT: ontrack fired, attaching stream to video');
        const [stream] = event.streams;
        video.srcObject = stream;
        video.muted = true;
        video.playsInline = true;

        video.onloadedmetadata = () => {
          console.log(
            'AGENT: video metadata loaded, videoWidth=',
            video.videoWidth,
            'videoHeight=',
            video.videoHeight
          );

          const playPromise = video.play();
          if (playPromise && typeof playPromise.then === 'function') {
            playPromise
              .then(() => console.log('AGENT: video playback started'))
              .catch((err) => console.error('AGENT: video play() blocked/failed:', err));
          }
        };
      };

      // ---------------------------------
      // Map video coords -> WINDOW coords
      // ---------------------------------
      function mapToWindowCoords(evt) {
        const rect = video.getBoundingClientRect();

        // relative position inside the rendered video rectangle
        const relX = (evt.clientX - rect.left) / rect.width;
        const relY = (evt.clientY - rect.top) / rect.height;

        // map directly to full window bounds (DIP)
        const x = relX * appWidth;
        const y = relY * appHeight;

        return { x, y };
      }

      // Mouse MOVE
      let lastMoveSent = 0;
      const MOVE_THROTTLE_MS = 50;

      video.addEventListener('mousemove', (evt) => {
        if (!video.videoWidth || !video.videoHeight) return;

        const now = Date.now();
        if (now - lastMoveSent < MOVE_THROTTLE_MS) return;
        lastMoveSent = now;

        const { x, y } = mapToWindowCoords(evt);

        socket.emit('control-event', {
          sessionId,
          event: {
            type: 'mouse',
            subtype: 'mouseMove',
            x,
            y,
            button: 'left'
          }
        });
      });

      // Mouse CLICK
      video.addEventListener('click', (evt) => {
        if (video.paused) {
          const playPromise = video.play();
          if (playPromise && typeof playPromise.then === 'function') {
            playPromise.catch((err) => {
              console.error('AGENT: video play() failed on click:', err);
            });
          }
        }

        if (!video.videoWidth || !video.videoHeight) {
          console.log('AGENT: click ignored, video not ready yet');
          return;
        }

        const { x, y } = mapToWindowCoords(evt);
        console.log('AGENT: sending click at window coords', { x, y });

        socket.emit('control-event', {
          sessionId,
          event: {
            type: 'mouse',
            subtype: 'mouseDown',
            x,
            y,
            button: 'left'
          }
        });

        socket.emit('control-event', {
          sessionId,
          event: {
            type: 'mouse',
            subtype: 'mouseUp',
            x,
            y,
            button: 'left'
          }
        });
      });

      // Keyboard forwarding (unchanged)
      window.addEventListener('keydown', (evt) => {
        socket.emit('control-event', {
          sessionId,
          event: {
            type: 'keyboard',
            subtype: 'keyDown',
            key: evt.key,
            code: evt.code,
            altKey: evt.altKey,
            shiftKey: evt.shiftKey,
            ctrlKey: evt.ctrlKey,
            metaKey: evt.metaKey
          }
        });
        evt.preventDefault();
      });

      window.addEventListener('keyup', (evt) => {
        socket.emit('control-event', {
          sessionId,
          event: {
            type: 'keyboard',
            subtype: 'keyUp',
            key: evt.key,
            code: evt.code,
            altKey: evt.altKey,
            shiftKey: evt.shiftKey,
            ctrlKey: evt.ctrlKey,
            metaKey: evt.metaKey
          }
        });
        evt.preventDefault();
      });
    </script>
  </body>
</html>